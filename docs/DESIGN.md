# 工作流程

### 配对引擎初始化

1. **订单传输队列**
   - 用来接受来自外部的（可能是多个订单流管道）的订单。本项目中所有的资产共用一个队列
2. **订单簿 (OrderBook) 容器**
   - 储存所有的订单簿容器地址
3. **LastPrice 最后成交价格**
   - 每个资产的最后成交价格。
4. **Observe 模式**
   - 通过一个`Oberve`接口把最后成交价格通知给OrderBook，触发止损单
   - `Observe`接口通也负责知行情接口生成实时行情
5. **TradeBook 所有成交订单的记录**
   - 储存所有成交纪录

### 订单簿初始化

1. **BBO价格层**
   - 最优买卖价格层的地址
2. **价格到价格层的哈希表映射**
   - 这里的每个价格层都是价格层双链表上的一个节点
3. **价格到止损订单节点的红黑树映射 `priceToStopOrder`**
   - 将价格映射到价格层的首个止损单节点
4. **订单Id到订单节点的映射 `orderIdToOrderNode`**
   - 这里的每个订单节点，都是同一个价格层内部的订单双链表上的节点
   - 用于根据订单Id迅速查找订单，便于订单节点的删除和修改
5. **订单空节点栈 `emptyOrderNodeStack`**
6. **价格层空节点栈 `emptyPriceLevelStack`**
   - 用于储存空节点，便于高效利用内存
   - 初始化时提前生成，分配大量空节点便于调用
7. **观察者接口**
   - 注册一个观察者接口，实时接收配对引擎中的最新成交价，触发止损单


### 订单处理

1. **市价单（Market Order）**：
   - 直接交给 `MatchingEngine` 处理市价单。市价单不需要进入订单簿，匹配引擎会立刻与当前的最佳价格进行撮合，直到市价单的需求被满足或市场上没有足够的流动性。

2. **限价单（Limit Order）**：
   - 首先判断限价单的价格是否会触发（即当前价格是否能够满足该限价单的要求）。
   - 如果可以立即成交，则直接交给 `MatchingEngine` 进行撮合。
   - 限价单撮合逻辑与市价单不同，消耗完对手方的限价单价格层后会转化成一个限价单节点。
   - 对于未能立即成交的部分，则将该限价单添加到 `OrderBook`，使用 `addOrder` 处理并维护价格层和订单链表结构。

3. **止损单（Stop Order）**：
   - 先判断止损单是否会立即触发，通常根据触发条件（如市价达到或超过止损单的触发价格）来确定。
   - 如果触发，则将止损单转为市价单，交给 `MatchingEngine` 处理。
   - 如果未触发，则使用 `OrderBook` 的 `addOrder` 方法，将其添加到红黑树管理的止损单结构中。
   - 之后，订单簿通过观察者接口持续接收最新成交价。
   - 如果达到触发条件，通过一个回调接口向配对引擎的订单队列提交市价单。

这种流程可以确保市价单被即时处理，限价单和止损单在符合条件时立即成交，否则会被妥善地存放在 `OrderBook` 中等待条件触发。
